<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - animation authoring</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        margin: 0px;
        background-color: #000000;
        color: #fff;
        font-family: Monospace;
        font-size: 15px;
        line-height: 30px;
        overflow: hidden;
      }
      #info {
        text-align: center;
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 15px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <script src="/three.min.js"></script>
    <script src="/dat.gui.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>
      var socket = io();
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const cubeAtts = [
        { position: { x: 0, y: 1, z: -4 }, rotation: { x: 0.01, y: 0.01 } },
        { position: { x: -2, y: 1, z: -2 }, rotation: { x: -0.01, y: 0.001 } },
        { position: { x: 4, y: 0, z: 2 }, rotation: { x: 0.005, y: -0.005 } },
        { position: { x: -4, y: -4, z: 0 }, rotation: { x: 0.001, y: 0.001 } },
      ]

      const createBox = (pos) => {
        // vanishingPoint
        const vp = { x: pos.x, y: pos.y, z: -500 }

        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshNormalMaterial();
        const cube = new THREE.Mesh(boxGeometry, material);
        cube.position.x = pos.x
        cube.position.y = pos.y
        cube.position.z = pos.z
        scene.add(cube);

        // draw line
        var lineMaterial = new THREE.LineBasicMaterial( { color: 0xf3f3f3 } );
        var lineGeometry = new THREE.Geometry();
        lineGeometry.vertices.push(new THREE.Vector3(pos.x, pos.y, pos.z) );
        lineGeometry.vertices.push(new THREE.Vector3(vp.x, vp.y, vp.z) );
        var line = new THREE.Line( lineGeometry, lineMaterial );
        scene.add(line)


        return cube
      }

      const cubes = cubeAtts.map((atts) => createBox(atts.position))

      // something helpful
      // var axesHelper = new THREE.AxesHelper( 5 );
      // scene.add( axesHelper );

      camera.position.z = 5;

      const cameraVerticaleAngle = 0; //begins assuming the camera is point straight forward

      // set up dat gui doh:
      // (example from: https://codepen.io/rachsmith/pen/qbKvdd)
      // var gui = new dat.GUI();
      // var cameraGui = gui.addFolder("camera projection");
      // cameraGui.add(camera, "fov");
      // cameraGui.open();
      //
      // var cubeGui = gui.addFolder("cube position");
      // cubeGui.add(cube.position, 'x');
      // cubeGui.add(cube.position, 'y');
      // cubeGui.add(cube.position, 'z');
      // cubeGui.open();

      // camera.position.y = 1.7;
      // camera.position.x = 1.7;

      socket.on("pos", function(pos) {
        const CAM_WIDTH_FOR_Z = 1024

        const CAMERA_WIDTH_PIXELS = 560
        const CAMERA_HEIGHT_PIXELS = 420

        const CAMERA_ABOVE_SCREEN = false

        let dotDistanceInMM = 8.5 * 25.4; //width of the wii sensor bar
        let screenHeightinMM = (13.0 * 25.4) // set to Tyler's 13 inch tall monitor
        const radiansPerPixelForZ = Math.PI / 4.0 / CAM_WIDTH_FOR_Z; //45 degree field of view with a 1024x768 camera
        const radiansPerPixelForXY = Math.PI / 4.0 / CAMERA_WIDTH_PIXELS; //45 degree field of view with a 1024x768 camera
        let movementScaling = 1.0;

        const { x, y, z } = pos
        const pointDist = CAM_WIDTH_FOR_Z - z;

        let angle = (radiansPerPixelForZ * pointDist) / 2;

        //in units of screen hieght since the box is a unit cube and box hieght is 1
        const headDist =
          (movementScaling * (dotDistanceInMM / 2.0 / Math.tan(angle))) /
          screenHeightinMM;

        const headX = (movementScaling *  Math.sin(radiansPerPixelForXY * (x - CAMERA_WIDTH_PIXELS / 2)) * headDist)

        const relativeVerticalAngle = (y - CAMERA_HEIGHT_PIXELS / 2) * radiansPerPixelForXY

        let headY
        if (CAMERA_ABOVE_SCREEN) {
          headY = 0.5 + (movementScaling * Math.sin(relativeVerticalAngle + cameraVerticaleAngle)  *headDist)
        } else {
          headY = -0.5 + (movementScaling * Math.sin(relativeVerticalAngle + cameraVerticaleAngle) * headDist)
        }


        // const val = 900 - pos.z;
        // // 9 == 4..16
        // // 500 == 400..900
        // const r = (val * 13) / 500;
        // console.log(`${pos.x}, ${pos.y}, ${pos.z}`);
        // camera.position.z = 4 + (16 - r);
        // console.log(headDist);
        camera.position.x = headX;
        camera.position.y = headY;
        camera.position.z = headDist;

        // console.log(camera.position)
      });

      var animate = function() {
        requestAnimationFrame(animate);

        cubes.forEach((cube, i) => {
          cube.rotation.x += cubeAtts[i].rotation.x;
          cube.rotation.y += cubeAtts[i].rotation.y;
        })

        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
